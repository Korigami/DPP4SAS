dppsampl package

Description: This package provides algorithms for sampling from the Determinantal Point Processes (DPPs) for SAS.

Determinantal Point Processes (DPPs) are stochastic processes which allow for sampling a subset from a set
while respecting the diversity present within the set.

Module Syntax:


EXACT SAMPLING:

proj_dpp_sampler_kernel_Chol(
	kernel, /*must be a projection correlation matrix*/
	 size=.,  /*value between 1 and rank(kernel)*/
	random_state=.);
For given projection correlation kernel matrix (K), 
the function returns a sample of given size (if size is not given then the output sample will be of size=rank(kernel). 
The sample is calculated using Cholesky based method. 


proj_dpp_sampler_kernel_shur(
	kernel, /*must be a projection correlation matrix*/
	size=., /*value between 1 and rank(kernel)*/
	random_seed=.)
For given correlation projection kernel matrix (K), 
the function returns a sample of given size (if size is not given then the output sample will be of size=rank(kernel). 
The sample is calculated using Shur based method.


proj_dpp_sampler_kernel_GS(
	kernel, *must be a projection correlation matrix*/
	size,  /*value between 1 and rank(kernel)*/
	random_state=.)
For given correlation projection kernel matrix (K),
the function returns a sample of given size (if size is not given then the output sample will be of size=rank(kernel). 
The sample is calculated using GS (Gram-Schmidt) method.


proj_dpp_sampler_eig_GS(
	eig_vecs, /*eigen vectors of correlation matrix*/
	size=., /*value between 1 and rank(kernel)*/
	random_state=.)
For given set of eigen vectors of a proper correlation kernel matrix, 
the function returns a sample of given size (if size is not given then the output sample will be of size=rank(kernel). 
The sample is calculated using GS (Gram-Schmidt) method.

proj_dpp_sampl_ker_eig_KuTa12(
	eig_vecs, /*eigen vectors of correlation matrix*/
	size=., /*value between 1 and rank(kernel)*/
	random_state=.)
For given set of eigen vectors of a proper correlation kernel matrix, 
the function returns a sample of given size (if size is not given then the output sample will be of size=rank(kernel). 
The sample is calculated using KuTa12 (Kulesza-Taskar) method.

sampler_generic(
	kernel,  /*correlation matrix K*/
	random_state=.)
For given correlation kernel matrix, the function returns a sample calculated with generic sampling algorithm. 
It is not possible to determine the size of the sample. 

MCMC:

add_exchange_delete_sampler(
	kernel, /*likelihood matrix L*/
	s0=., /*initial sample*/
	random_state=., 
	nb_iter=10/*number of iterations*/)
For given likelihood matrix, the function returns a sample calculated by adding, exchanging or removing an element 
(with specific probabilities) from given samples (starting from initial s0 sample) for a number of iterations specified by the nb_iter parameter. 
If the initial sample - s0 is not provided, then it is generated by the algorithm. 
It is not possible to determine the size of the sample. 

add_delete_sampler(
	kernel,/*likelihood matrix L*/
	s0=., /*initial sample*/
	size_s0=.,/*specified size of initial sample that will be generated by the algorithm if 		s0 is not provided*/
	random_state=., 
	nb_iter=100/*number of iterations*/, 
	nb_trials=100/*number of trials for generating initial sample*/)
For given likelihood matrix, the function returns a sample calculated by adding or removing an element 
(with specific probabilities) from given samples (starting from initial s0 sample) for a number of iterations specified by the nb_iter parameter. 
If the initial sample - s0 is not provided, then it is generated by the algorithm. 
It is not possible to determine the size of the output sample, however it is possible to provide a size of the generated initial sample. 

basic_exchange_sampler(
	kernel, /*likelihood matrix L*/
	s0=.,/*initial sample*/
	size_s0 = ., /*specified size of initial sample that will be generated by the algorithm 		if s0 is not provided*/
	random_state=. , 
	nb_iter=100, /*number of iterations*/,
	nb_trials=100/*number of trials for generating initial sample*/))

For given likelihood matrix, the function returns a sample calculated by exchanging an element 
(with specific probability) from given samples (starting from initial s0 sample) for a number of iterations specified by the nb_iter parameter. 
If the initial sample - s0 is not provided, then it is generated by the algorithm.
As the only operation performed during the algorithm is exchanging elements, the output sample will be of the same size as the initial s0 sample, 
thus it is possible to specify the size of the sample. 


BETA ENSAMBLES:

sample_from_beta_ensemble_full( 
	ensemble_version, 
	M_1, M_2, /* M variables only for Laguerre (first) and Jacobi (both). They should be >= Size*/
	size=10, 
	beta=2, 
	normalize=1, 
	haar_mode="Hermite", /* haar_mode only available for circular ensemble */
	heurestic_fix=1, /* heurestic_fix only available for circular ensemble */
	random_state=1618); 

    Samples from Beta ensemble using the full matrix method. 
    Returns a sample of 1 column (for ensemble_version = "Hermite", "Laguerre", or "Jacobi") 
    or of 2 columns (for ensemble_version = "Circular" or "Ginibre").
	Increase of beta or size should result in more "spread out" distribution.

sample_from_beta_ensemble_banded(
	ensemble_version, 
	size=10, 
	beta=2, 
	/* distribution specific parameters */
	loc=0.0, 
	scale=1.0, 
	shape = 1.0,
	a = 1.0,
	b = 1.0,
	/* parameters for the algorithm */
	normalize=1, 
	heurestic_fix=1,
	random_state=1618);

    Samples from Beta ensemble using the banded (that is 3- or 5-diagonal) matrix method. 
    Returns a sample of 1 column (for ensemble_version = "Hermite", "Laguerre", or "Jacobi") 
    or of 2 columns (for ensemble_version = "Circular").
	Increase of beta or size should result in more "spread out" distribution.

EXOTIC DPPs:

poiss_planch_sample(
	theta=10/*parameter of poisson distribution, must be integer >1, 
	random_state=.)

Generates a sample from the Poissonized Plancherel method by using RSK (Robinson-Schensted-Knuth) 
algorithm on a random permutation on {1, N} where N is generated from Poisson distribution with parameter theta. 
It is not possible to determine the size of the output sample (it will always be <= theta). 

carries_sample(
	base=10, /*must be >1*/
	size=100, /*size of the generated list, upper bound of output sample, must be >1*/
	random_state=.)
Generates a sample by creating the sequence of Carries. 
A sequence of  i.i.d. digits of a given size is generated and the cumulative sum is computed. 
The base parameter specifies the number by which each element of a sequence is divided to generate the rest. 
It is not possible to determine the size of the output sample (it will always be <size). 

descent_sample(
	size=100/*size of the generated list, upper bound of output sample, must be >1*/,
	random_state=.)
Generates a sample by creating a descent process obtained from a uniformly chosen permutation of {1,..,size}.  
It is not possible to determine the size of the output sample (it will always be < size). 


virtual_descent_sample(
	size=100 /*size of the generated list, upper bound of output sample, must be >1*/, 
	x0=0.5 /*the parameter of binomial distribution*/, 
	random_state=.)
Generates a sample from a mix of DPPs by obtaining a non-uniformly chosen permutation of {0,â€¦,size-1} 
(using binomial distribution with specified x0 parameter). 
It is not possible to determine the size of the output sample (it will always be < size). 
